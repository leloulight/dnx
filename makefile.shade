use assembly="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
use assembly="System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
use import="Environment"
use import="Regex"
use import="Json"
use namespace="System.IO"
use namespace="System.Linq"
use namespace="System.Xml.Linq"

var PRODUCT_VERSION = '1.0.0'
var AUTHORS='Microsoft Open Technologies, Inc.'

use-standard-lifecycle

- // Need this to run before nuget-verify
#package-runtime .clean-sdk-dir target='package'

k-standard-goals

var Configuration2='${E("Configuration")}'
var ROOT = '${Directory.GetCurrentDirectory()}'
var SCRIPTS_DIR = '${Path.Combine(ROOT, "scripts")}'
var ARTIFACTS_DIR = '${Path.Combine(ROOT, "artifacts")}'
var BUILD_DIR2 = '${Path.Combine(ROOT, "artifacts", "build")}'
var NUSPEC_ROOT = '${Path.Combine(ROOT, "nuspec")}'
var SAMPLES_DIR = '${Path.Combine(ROOT, "samples")}'
var FULL_VERSION = '${PRODUCT_VERSION + "-" + E("DNX_BUILD_VERSION")}'
var CORECLR_TARGET_PATH = '${Path.Combine(BUILD_DIR2, "DnxCoreCLR")}'
var RUNTIME_NAME_PREFIX = 'dnx-'

- // Runtime names

var RUNTIME_MONO_NAME = '${RUNTIME_NAME_PREFIX + "mono"}'
var RUNTIME_CLR_WIN_x86_NAME = '${RUNTIME_NAME_PREFIX + "clr-win-x86"}'
var RUNTIME_CLR_WIN_x64_NAME = '${RUNTIME_NAME_PREFIX + "clr-win-x64"}'
var RUNTIME_CORECLR_WIN_x86_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-win-x86"}'
var RUNTIME_CORECLR_WIN_x64_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-win-x64"}'
var RUNTIME_CORECLR_WIN_arm_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-win-arm"}'
var RUNTIME_CORECLR_DARWIN_x64_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-darwin-x64"}'
var RUNTIME_CORECLR_LINUX_x64_NAME = '${RUNTIME_NAME_PREFIX + "coreclr-linux-x64"}'

- // Runtime paths
var RUNTIME_MONO_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_MONO_NAME, "bin")}'
var RUNTIME_CLR_WIN_x86_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CLR_WIN_x86_NAME, "bin")}'
var RUNTIME_CLR_WIN_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CLR_WIN_x64_NAME, "bin")}'
var RUNTIME_CORECLR_WIN_x86_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_WIN_x86_NAME, "bin")}'
var RUNTIME_CORECLR_WIN_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_WIN_x64_NAME, "bin")}'
var RUNTIME_CORECLR_WIN_arm_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_WIN_arm_NAME, "bin")}'
var RUNTIME_CORECLR_DARWIN_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_DARWIN_x64_NAME, "bin")}'
var RUNTIME_CORECLR_LINUX_x64_BIN = '${Path.Combine(BUILD_DIR2, RUNTIME_CORECLR_LINUX_x64_NAME, "bin")}'

var RUNTIME_CLR_TARGETS = '${new [] {RUNTIME_MONO_BIN, RUNTIME_CLR_WIN_x86_BIN, RUNTIME_CLR_WIN_x64_BIN}}'
var RUNTIME_CORECLR_TARGETS = '${new [] {RUNTIME_CORECLR_WIN_x86_BIN, RUNTIME_CORECLR_WIN_x64_BIN, RUNTIME_CORECLR_WIN_arm_BIN, RUNTIME_CORECLR_DARWIN_x64_BIN, RUNTIME_CORECLR_LINUX_x64_BIN }}'
var ALL_TARGETS = '${RUNTIME_CLR_TARGETS.Concat(RUNTIME_CORECLR_TARGETS)}'

var BOOTSTRAPPER_FOLDER_NAME = 'dnx'
var BOOTSTRAPPER_EXE_NAME = 'dnx'
var BOOTSTRAPPER_WINDOWS_FOLDER_NAME="dnx.windows"
var BOOTSTRAPPER_CLR_NAME = 'dnx.clr'
var BOOTSTRAPPER_CORECLR_NAME = 'dnx.coreclr'
var BOOTSTRAPPER_CLR_MANAGED_NAME = 'Microsoft.Dnx.Host.Clr'
var BOOTSTRAPPER_CORECLR_MANAGED_NAME = 'Microsoft.Dnx.Host.CoreClr'
var BOOTSTRAPPER_MONO_MANAGED_NAME = 'Microsoft.Dnx.Host.Mono'
var BOOTSTRAPPER_HOST_NAME = 'Microsoft.Dnx.Host'
var BOOTSTRAPPER_COMMON_FOLDER_NAME = 'dnx.common'

var PROGRAM_FILES_X86 = '${Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86)}'
var MSBUILD = '${Path.Combine(PROGRAM_FILES_X86, "MSBuild", "14.0", "Bin", "MSBuild.exe")}'
var VS_REDIST_ROOT = '${Path.Combine(PROGRAM_FILES_X86, @"Microsoft Visual Studio 14.0\VC\redist")}'
var WIN10_SDK_LIB = '${Path.Combine(PROGRAM_FILES_X86, @"Windows Kits\10\Lib")}'
var VS_ONECORE_ROOT = '${Path.Combine(PROGRAM_FILES_X86, @"Microsoft Visual Studio 14.0\VC\lib\onecore")}'
var CLANG = '${SearchForClang()}'

var MANAGED_PROJECTS = '${FindAllProjects(
    BOOTSTRAPPER_HOST_NAME,
    BOOTSTRAPPER_CORECLR_MANAGED_NAME,
    "Microsoft.Dnx.ApplicationHost",
    "Microsoft.Dnx.Compilation",
    "Microsoft.Extensions.CompilationAbstractions",
    "Microsoft.Dnx.Compilation.CSharp",
    "Microsoft.Dnx.Compilation.CSharp.Abstractions",
    "Microsoft.Dnx.Compilation.CSharp.Common",
    "Microsoft.Dnx.Compilation.DesignTime",
    "Microsoft.Dnx.DesignTimeHost",
    "Microsoft.Dnx.DesignTimeHost.Abstractions",
    "Microsoft.Dnx.Loader",
    "Microsoft.Dnx.Runtime",
    "Microsoft.Extensions.PlatformAbstractions",
    "Microsoft.Dnx.Runtime.CommandParsing.Sources",
    "Microsoft.Dnx.Runtime.Internals",
    "Microsoft.Extensions.JsonParser.Sources",
    "Microsoft.Dnx.Runtime.Sources",
    "Microsoft.Dnx.Project",
    "Microsoft.Dnx.Tooling",
    "Microsoft.Extensions.CommandLineUtils.Sources")}'

var WIN_MANAGED_PROJECTS = '${FindAllProjects(
    BOOTSTRAPPER_CLR_MANAGED_NAME)}'

var RUNTIME_TARGETS='${new List<RuntimeTarget>()}'

var CAN_BUILD_ONECORE = '${Directory.Exists(VS_ONECORE_ROOT) && Directory.GetFiles(VS_ONECORE_ROOT, "vcruntime.lib", SearchOption.AllDirectories).Any() && Directory.Exists(WIN10_SDK_LIB) && Directory.GetFiles(WIN10_SDK_LIB, "onecore.lib", SearchOption.AllDirectories).Any()}'

@{
    // Always build mono
    RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_MONO_NAME, TargetFolder = RUNTIME_MONO_BIN, Framework = "dnx451", Arch = "any", OS = "any", Flavor = "mono" });

    if (CanBuildForWindows)
    {
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CLR_WIN_x86_NAME,     TargetFolder = RUNTIME_CLR_WIN_x86_BIN,     Framework = "dnx451",     Arch = "x86", OS = "win", Flavor = "clr" });
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CLR_WIN_x64_NAME,     TargetFolder = RUNTIME_CLR_WIN_x64_BIN,     Framework = "dnx451",     Arch = "x64", OS = "win", Flavor = "clr" });
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_WIN_x86_NAME, TargetFolder = RUNTIME_CORECLR_WIN_x86_BIN, Framework = "dnxcore50",  Arch = "x86", OS = "win", Flavor = "coreclr" });
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_WIN_x64_NAME, TargetFolder = RUNTIME_CORECLR_WIN_x64_BIN, Framework = "dnxcore50",  Arch = "x64", OS = "win", Flavor = "coreclr" });

        if (CAN_BUILD_ONECORE)
        {
            RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_WIN_arm_NAME, TargetFolder = RUNTIME_CORECLR_WIN_arm_BIN, Framework = "dnxcore50",  Arch = "arm", OS = "win", Flavor = "coreclr" });
        }
    }

    if (CanBuildForLinux)
    {
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_LINUX_x64_NAME, TargetFolder = RUNTIME_CORECLR_LINUX_x64_BIN,  Framework = "dnxcore50",  Arch = "x64", OS = "linux", Flavor = "coreclr" });
    }

    if (CanBuildForDarwin)
    {
        RUNTIME_TARGETS.Add(new RuntimeTarget { Name = RUNTIME_CORECLR_DARWIN_x64_NAME, TargetFolder = RUNTIME_CORECLR_DARWIN_x64_BIN, Framework = "dnxcore50",  Arch = "x64", OS = "darwin", Flavor = "coreclr" });
    }

    // Temporary until KoreBuild is updated
    // It looks like it isn't possible to do this in .travis.yml because we only want
    // to do it on Linux and I couldn't find an easy way to do that kind of selective
    // environment variable set.
    if(E('TRAVIS') == "true" && CanBuildForLinux)
    {
        E('DNX_RUNTIME_ID', 'ubuntu.14.04-x64');
    }
}

-// Replace repo-initialize with a less greedy restore
#repo-initialize target='initialize'
    git gitCommand="submodule update --init"
    @{
        DoRestore("default -runtime coreclr");
    }

- // k-standard-goal overrides
#native-compile

#build-compile target='compile'

#xunit-test

-// Specific to building the dnx
#build-common target='build-compile'
#package-common target='package-runtime'

-// Define platform specific builds as a n00p if the current platform can't produce a build
#build-darwin target='build-compile' if='CanBuildForDarwin'
#build-darwin if='!CanBuildForDarwin'

#package-darwin target='package-runtime' if='CanBuildForDarwin'
#package-darwin if='CanBuildForDarwin'

#build-linux target='build-compile' if='CanBuildForLinux'
#build-linux if='!CanBuildForLinux'

#package-linux target='package-runtime' if='CanBuildForLinux'
#package-linux if='CanBuildForLinux'

#build-windows target='build-compile' if='CanBuildForWindows'
#build-windows if='!CanBuildForWindows'

#package-windows target='package-runtime' if='CanBuildForWindows'
#package-windows if='!CanBuildForWindows'

- // ===================== BUILD =====================

- // ===================== COMMON =====================

#build-managed-projects target='build-common'
    @{
        var BUILD_DIR = BUILD_DIR2;
        if (IsBuildV2)
        {
              DnuPack("src/**", BUILD_DIR, Configuration2);
        }
        else
        {
            foreach(var projectFile in MANAGED_PROJECTS)
            {
                DnuPack(projectFile, BUILD_DIR, Configuration2);
            }
        }
        foreach (var nupkg in Files.Include(Path.Combine(BUILD_DIR, "*/*.nupkg")))
        {
            File.Copy(nupkg, Path.Combine(BUILD_DIR, Path.GetFileName(nupkg)), true);
        }
    }

-// This target's build-common since mono is built on all platforms
#build-dnx-mono-bootstrapper target='build-common'
    var monoManagedOutpath='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_MONO_MANAGED_NAME)}'
    directory create='${monoManagedOutpath}'
    @{
        var bootstrapperAssembly = Path.Combine(BUILD_DIR2, BOOTSTRAPPER_HOST_NAME, "dnx451", BOOTSTRAPPER_HOST_NAME + ".dll");

        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_MONO_MANAGED_NAME, "EntryPoint.cs")
        };

        var arguments = string.Format(
            @"/target:exe /nologo /unsafe /out:""{0}"" /r:""{1}"" /define:DNX451 {2}",
            Path.Combine(monoManagedOutpath, BOOTSTRAPPER_MONO_MANAGED_NAME + ".dll"),
            bootstrapperAssembly,
            string.Join(" ", sourceFiles));

        var compiler = IsMono ? "mcs" : Path.Combine(Environment.GetEnvironmentVariable("WINDIR"), "Microsoft.NET", "Framework", "v4.0.30319", "csc.exe");

        Exec(compiler, arguments);
    }

#clean-sdk-dir
    directory each='var delete in ALL_TARGETS.Select(t => Path.GetDirectoryName(t))'
    directory each='var create in RUNTIME_TARGETS.Select(t => t.TargetFolder)'

- // ===================== WINDOWS =====================

#build-win-managed-projects target='build-windows'
    @{ var BUILD_DIR = BUILD_DIR2; }
    kpm-pack each='var projectFile in WIN_MANAGED_PROJECTS' configuration='${Configuration2}' kpmPackOutputDir='${BUILD_DIR}'
    @{
        foreach (var nupkg in Files.Include(Path.Combine(BUILD_DIR, "*/*.nupkg")))
        {
            File.Copy(nupkg, Path.Combine(BUILD_DIR, Path.GetFileName(nupkg)), true);
        }
    }

#build-dnx-win-exe .ensure-msbuild target='build-windows'
    var bootstrapperProj = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_WINDOWS_FOLDER_NAME, "dnx.windows.vcxproj")}'

    @{
        var commonParameters =
            " /p:Configuration=" + Configuration2 +
            " /p:ProductVersion=" + PRODUCT_VERSION +
            " /p:FileRevision=" + E("DNX_ASSEMBLY_FILE_VERSION") +
            " /p:BuildVersion=" + E("DNX_BUILD_VERSION");

        var environmentRuntimeTargetOS = Environment.GetEnvironmentVariable("RUNTIME_TARGET_OS");
        var configRuntimeTargetOS = "";

        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=Win32;TargetFramework=dnx451;RuntimeType=CLR");
        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=x64;TargetFramework=dnx451;RuntimeType=CLR");

        if (environmentRuntimeTargetOS == "WIN7_PLUS_CORESYSTEM")
        {
            configRuntimeTargetOS = ";RuntimeTargetOS=WIN7_PLUS_CORESYSTEM";
        }

        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=Win32;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN" + configRuntimeTargetOS);
        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=x64;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN" + configRuntimeTargetOS);
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_WINDOWS_FOLDER_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_WINDOWS_FOLDER_NAME)}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_WINDOWS_FOLDER_NAME)}' overwrite='${true}'

#build-dnx-win-dll .ensure-msbuild target='build-windows'
    var bootstrapperProj = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_FOLDER_NAME, "dnx.vcxproj")}'
    @{
        var commonParameters =
            " /p:Configuration=" + Configuration2 +
            " /p:ProductVersion=" + PRODUCT_VERSION +
            " /p:FileRevision=" + E("DNX_ASSEMBLY_FILE_VERSION") +
            " /p:BuildVersion=" + E("DNX_BUILD_VERSION");

        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=Win32;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=x64;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=Win32;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=x64;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=False");

        if (CAN_BUILD_ONECORE)
        {
            Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=Win32;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=True");
            Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=x64;TargetFramework=dnx451;RuntimeType=CLR;BuildForOneCore=True");
            Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=Win32;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=True");
            Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=x64;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN;BuildForOneCore=True");

            Exec(MSBUILD, bootstrapperProj + commonParameters + ";Platform=ARM;TargetFramework=dnxcore50;RuntimeType=CORECLR_WIN");
        }
        else
        {
            Log.Warn("Windows 10 SDK not installed. Building for One Core skipped.");
        }
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_FOLDER_NAME)}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME)}' overwrite='${true}'

#build-dnx-coreclr-win-bootstrapper .ensure-msbuild .update-tpa target='build-windows'
    var bootstrapperCoreClrProj = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME, BOOTSTRAPPER_CORECLR_NAME + ".vcxproj")}'
    @{
        var commonParameters =
            " /p:Configuration=" + Configuration2 +
            " /p:ProductVersion=" + PRODUCT_VERSION +
            " /p:FileRevision=" + E("DNX_ASSEMBLY_FILE_VERSION") +
            " /p:BuildVersion=" + E("DNX_BUILD_VERSION");

        Exec(MSBUILD, bootstrapperCoreClrProj + commonParameters + ";Platform=Win32;BuildForOneCore=False");
        Exec(MSBUILD, bootstrapperCoreClrProj + commonParameters + ";Platform=x64;BuildForOneCore=False");

        if (CAN_BUILD_ONECORE)
        {
            Exec(MSBUILD, bootstrapperCoreClrProj + commonParameters + ";Platform=Win32;BuildForOneCore=True");
            Exec(MSBUILD, bootstrapperCoreClrProj + commonParameters + ";Platform=x64;BuildForOneCore=True");

            Exec(MSBUILD, bootstrapperCoreClrProj + commonParameters + ";Platform=ARM");
        }
        else
        {
            Log.Warn("Windows 10 SDK not installed. Building for One Core skipped.");
        }
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME)}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME)}' overwrite='${true}'

#build-dnx-clr-win-bootstrapper .ensure-msbuild target='build-windows'
    var bootstrapperClrProj ='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_NAME, BOOTSTRAPPER_CLR_NAME + ".vcxproj")}'
    @{
        var commonParameters =
            " /p:Configuration=" + Configuration2 +
            " /p:ProductVersion=" + PRODUCT_VERSION +
            " /p:FileRevision=" + E("DNX_ASSEMBLY_FILE_VERSION") +
            " /p:BuildVersion=" + E("DNX_BUILD_VERSION");

        Exec(MSBUILD, bootstrapperClrProj + commonParameters + ";Platform=Win32");
        Exec(MSBUILD, bootstrapperClrProj + commonParameters + ";Platform=x64");
    }

    directory delete='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME)}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_NAME)}' include='bin/**/' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME)}' overwrite='${true}'

- // ===================== LINUX =====================

#build-dnx-coreclr-linux-bootstrapper .ensure-clang .update-tpa target='build-linux'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "bin")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_CORECLR_NAME + ".so")}'
    @{
        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "tpa.cpp"),
            Path.Combine("src", BOOTSTRAPPER_CORECLR_NAME + ".unix", BOOTSTRAPPER_CORECLR_NAME + ".cpp"),
            Path.Combine("src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "utils.cpp")
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("-fPIC -shared {0} -g -o {1} -DPLATFORM_LINUX --std=c++11 -ldl -Isrc/{2}/include",
            string.Join(" ", sourceFiles), soOutputPath, BOOTSTRAPPER_COMMON_FOLDER_NAME));
    }

    copy sourceDir='${soOutputDir}' include='*.so' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' overwrite='${true}'

#build-dnx-linux-bootstrapper .ensure-clang target='build-linux'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_FOLDER_NAME, "bin", "x64")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_EXE_NAME)}'
    @{
        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, "main.cpp"),
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, BOOTSTRAPPER_EXE_NAME + ".cpp"),
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, "pal.unix.cpp"),
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, "pal.linux.cpp"),
            Path.Combine("src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "utils.cpp")
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("{0} -g -o {1} -DCORECLR_LINUX -DPLATFORM_UNIX -std=c++11 -ldl -lpthread -Isrc/{2}/include",
            string.Join(" ", sourceFiles), soOutputPath, BOOTSTRAPPER_COMMON_FOLDER_NAME));
    }

    copy sourceDir='${soOutputDir}' include='*' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "linux", "x64")}' overwrite='${true}'


- // ===================== DARWIN (OSX) =====================

#build-dnx-coreclr-darwin-bootstrapper .ensure-clang .update-tpa target='build-darwin'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_CORECLR_NAME + ".unix", "bin")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_CORECLR_NAME + ".dylib")}'
    @{
        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "tpa.cpp"),
            Path.Combine("src", BOOTSTRAPPER_CORECLR_NAME + ".unix", BOOTSTRAPPER_CORECLR_NAME + ".cpp"),
            Path.Combine("src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "utils.cpp")
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("-fPIC -shared {0} -g -o {1} -DPLATFORM_DARWIN --std=c++11 -ldl -Isrc/{2}/include",
            string.Join(" ", sourceFiles), soOutputPath, BOOTSTRAPPER_COMMON_FOLDER_NAME));
    }

    copy sourceDir='${soOutputDir}' include='*.dylib' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' overwrite='${true}'

#build-dnx-darwin-bootstrapper .ensure-clang target='build-darwin'
    var soOutputDir = '${Path.Combine(ROOT, "src", BOOTSTRAPPER_FOLDER_NAME, "bin", "x64")}'
    var soOutputPath = '${Path.Combine(soOutputDir, BOOTSTRAPPER_EXE_NAME)}'
    @{
        var sourceFiles = new string[]
        {
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, "main.cpp"),
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, BOOTSTRAPPER_EXE_NAME + ".cpp"),
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, "pal.unix.cpp"),
            Path.Combine("src", BOOTSTRAPPER_FOLDER_NAME, "pal.darwin.cpp"),
            Path.Combine("src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "utils.cpp")
        };

        Directory.CreateDirectory(soOutputDir);

        Exec(CLANG, string.Format("{0} -g -o {1} -DCORECLR_DARWIN -DPLATFORM_UNIX -std=c++11 -ldl -lpthread -Isrc/{2}/include",
            string.Join(" ", sourceFiles), soOutputPath, BOOTSTRAPPER_COMMON_FOLDER_NAME));
    }

    copy sourceDir='${soOutputDir}' include='*' outputDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "darwin", "x64")}' overwrite='${true}'

- // ===================== PACKAGE =====================

#copy-required-dependencies
     @{
        var sdkProjects = new[]
        {
            "Microsoft.Dnx.DesignTimeHost",
            "Microsoft.Dnx.Project",
            "Microsoft.Dnx.Tooling"
        };

        // native assemblies loaded by System.Net.Http.dll at runtime
        var nativeLibraries = new []
        {
            "System.Net.Http.Native",
            "System.Security.Cryptography.Native"
        };

        foreach (var target in RUNTIME_TARGETS)
        {
            // Parse and copy runtime assemblies
            var projectFolder = Path.Combine(ROOT, "src", "Microsoft.Dnx");
            var runtimeAssemblies = CopyRequiredAssemblies(projectFolder, target.TargetFolder, ignoreDependencies: null, target: target);

            // Parse and copy lib assemblies
            foreach (var project in sdkProjects)
            {
                var sdkFolder = Path.Combine(ROOT, "src", project);
                var targetLibDir = Path.Combine(target.TargetFolder, "lib", project);
                CopyRequiredAssemblies(sdkFolder, targetLibDir, runtimeAssemblies, target);
            }

            // Copy required CoreCLR assemblies
            if (target.Flavor == "coreclr")
            {
                var nativeExtension = target.OS == "linux" ? ".so" : ".dylib";

                if (target.OS != "win")
                {
                    foreach (var native in nativeLibraries)
                    {
                        var targetFilePath = Path.Combine(target.TargetFolder, "lib", "Microsoft.Dnx.Tooling", native + nativeExtension);
                        var sourceFile = Path.Combine(target.TargetFolder, native + nativeExtension);
                        if (File.Exists(sourceFile))
                        {
                            if (!Quiet)
                            {
                                Log.Info("Copying " + sourceFile + " to " + targetFilePath);
                            }
                            File.Copy(sourceFile, targetFilePath);
                        }
                        else
                        {
                            Log.Warn(sourceFile + " does not exist");
                        }
                    }
                }
            }
        }
    }

#copy-common .copy-required-dependencies target='package-common'
    copy sourceDir='${SCRIPTS_DIR}' include='*.sh' outputDir='${RUNTIME_MONO_BIN}' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_MONO_MANAGED_NAME)}' outputDir='${RUNTIME_MONO_BIN}' include='*.dll' overwrite='${true}'
    @{
        FixShFiles(RUNTIME_MONO_BIN);
    }

    -// Copy built projects to the appropriate locations

    @{
        var dnxCore50Pattern = Path.Combine(BUILD_DIR2, "*", "dnxcore50", "**.*");
        var dotnet54Pattern = Path.Combine(BUILD_DIR2, "*", "dotnet5.4", "**.*");
        var dnx451Pattern = Path.Combine(BUILD_DIR2, "*", "dnx451", "**.*");
        var net451Pattern = Path.Combine(BUILD_DIR2, "*", "net451", "**.*");

        var libPackages = new[] { "Microsoft.Dnx.Project",
                                  "Microsoft.Dnx.DesignTimeHost",
                                  "Microsoft.Dnx.Tooling" };

        var sharedSourceAssemblies = new [] {
            Path.Combine(BUILD_DIR2, "Microsoft.Dnx.Runtime.Sources/**/*.*"),
            Path.Combine(BUILD_DIR2, "Microsoft.Dnx.Runtime.CommandParsing.Sources/**/*.*"),
            Path.Combine(BUILD_DIR2, "Microsoft.Extensions.JsonParser.Sources/**/*.*"),
            Path.Combine(BUILD_DIR2, "Microsoft.Extensions.CommandLineUtils.Sources/**/*.*"),
        };

        foreach (var file in Files.Include(dnxCore50Pattern, dotnet54Pattern).Exclude(sharedSourceAssemblies))
        {
            foreach (var runtimeTarget in RUNTIME_TARGETS.Where(t => t.Flavor == "coreclr"))
            {
                string dest = Path.Combine(runtimeTarget.TargetFolder, Path.GetFileName(file));
                File.Copy(file, dest, true);
            }
        }

        foreach (var file in Files.Include(dnx451Pattern, net451Pattern).Exclude(sharedSourceAssemblies))
        {
            foreach (var runtimeTarget in RUNTIME_TARGETS.Where(t => t.Flavor != "coreclr"))
            {
                string dest = Path.Combine(runtimeTarget.TargetFolder, Path.GetFileName(file));
                File.Copy(file, dest, true);
            }
        }

        // Clean up net45.managed from mono (it's never used)
        File.Delete(Path.Combine(RUNTIME_MONO_BIN, BOOTSTRAPPER_CLR_MANAGED_NAME + ".dll"));

        Action<string, string, string> move = (binFolder, name, extension) =>
        {
            var libPath = Path.Combine(binFolder, "lib", name);
            var source = Path.Combine(binFolder, name + extension);
            var target = Path.Combine(libPath, name + extension);

            if (File.Exists(source))
            {
                if (File.Exists(target))
                {
                    File.Delete(target);
                }

                Directory.CreateDirectory(libPath);
                if (!Quiet)
                {
                    Log.Info("Moving " + name + " to " + target);
                }
                File.Move(source, target);
            }
            else
            {
                Log.Warn(source + " does not exist in " + binFolder);
            }
        };

        // Move some packages into the lib/ folder
        foreach (var libPackage in libPackages)
        {
            foreach (var runtimeTarget in RUNTIME_TARGETS)
            {
                move(runtimeTarget.TargetFolder, libPackage, ".dll");
                if (!IsLinux)
                {
                    move(runtimeTarget.TargetFolder, libPackage, ".pdb");
                }
            }
        }
    }

#copy-windows-bits .ensure-vs-redist target='package-windows'
    -// Runtime for clr-win-x86
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "Win32", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_WINDOWS_FOLDER_NAME, "bin", "Win32", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.pdb' overwrite='${true}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_MANAGED_NAME)}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='*.config' overwrite='${true}'

    -// Runtime for clr-win-x64
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "x64", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_WINDOWS_FOLDER_NAME, "bin", "x64", Configuration2, "dnx451")}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.pdb' overwrite='${true}'
    copy sourceDir='${Path.Combine(ROOT, "src", BOOTSTRAPPER_CLR_MANAGED_NAME)}' outputDir='${RUNTIME_CLR_WIN_x64_BIN}' include='*.config' overwrite='${true}'

    -// Runtime for coreclr-win-x86
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "Win32", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_WINDOWS_FOLDER_NAME, "bin", "Win32", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "Win32", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x86_BIN}' include='*.pdb' overwrite='${true}'
    -// Since we can't build debug versions of some native binaries for CoreClr/OneCore we only copy ret version of vcruntime dll
    copy sourceDir='${Path.Combine(VS_REDIST_ROOT, @"onecore\x86\Microsoft.VC140.CRT")}' outputDir='${RUNTIME_CLR_WIN_x86_BIN}' include='vcruntime140.dll' overwrite='${true}' if='Configuration2 == "Release"'

    -// Runtime for coreclr-win-x64
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "x64", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_WINDOWS_FOLDER_NAME, "bin", "x64", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.exe' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.dll' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "x64", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='*.pdb' overwrite='${true}'
    -// Since we can't build debug versions of some native binaries for CoreClr/OneCore we only copy ret version of vcruntime dll
    copy sourceDir='${Path.Combine(VS_REDIST_ROOT, @"onecore\x64\Microsoft.VC140.CRT")}' outputDir='${RUNTIME_CORECLR_WIN_x64_BIN}' include='vcruntime140.dll' overwrite='${true}' if='Configuration2 == "Release"'

    -// Runtime for coreclr-win-arm
     copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "ARM", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_arm_BIN}' include='*.exe' overwrite='${true}' if='CAN_BUILD_ONECORE'
     copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "ARM", Configuration2, "dnxcore50")}' outputDir='${RUNTIME_CORECLR_WIN_arm_BIN}' include='*.pdb' overwrite='${true}' if='CAN_BUILD_ONECORE'
     copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "ARM", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_arm_BIN}' include='*.dll' overwrite='${true}' if='CAN_BUILD_ONECORE'
     copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME, "bin", "ARM", Configuration2)}' outputDir='${RUNTIME_CORECLR_WIN_arm_BIN}' include='*.pdb' overwrite='${true}' if='CAN_BUILD_ONECORE'

    -// Copy cmd files
    copy sourceDir='${SCRIPTS_DIR}' include='*.cmd' exclude='dnx-crossgen.cmd' overwrite='${true}' each='var outputDir in new[]{ RUNTIME_CLR_WIN_x86_BIN, RUNTIME_CLR_WIN_x64_BIN}'
    copy sourceDir='${SCRIPTS_DIR}' include='*.cmd' overwrite='${true}' each='var outputDir in new[]{ RUNTIME_CORECLR_WIN_x86_BIN, RUNTIME_CORECLR_WIN_x64_BIN }'
    copy sourceDir='${SCRIPTS_DIR}' include='*.cmd' overwrite='${true}' each='var outputDir in new[]{ RUNTIME_CORECLR_WIN_arm_BIN }' if='CAN_BUILD_ONECORE'

#copy-linux-bits target='package-linux'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' include='*.so' outputDir='${RUNTIME_CORECLR_LINUX_x64_BIN}' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "linux", "x64")}' include='dnx' outputDir='${RUNTIME_CORECLR_LINUX_x64_BIN}' overwrite='${true}'
    copy sourceDir='${SCRIPTS_DIR}' include='dnu.sh' outputDir='${RUNTIME_CORECLR_LINUX_x64_BIN}' overwrite='${true}'
    @{
        FixShFiles(RUNTIME_CORECLR_LINUX_x64_BIN);
    }

var CI_LINUX_DROP_PATH = '${Environment.GetEnvironmentVariable("CI_LINUX_DROP_PATH")}'

#copy-ci-linux-bits target='package-runtime' if='!string.IsNullOrEmpty(CI_LINUX_DROP_PATH)'
    @{
        var extractDirectory = Path.Combine(ARTIFACTS_DIR, "Dnx.Linux");
    }

    copy sourceDir='${CI_LINUX_DROP_PATH}' outputDir='${extractDirectory}' include='*.nupkg' overwrite='${true}'

    @{
        foreach (var package in Directory.EnumerateFiles(extractDirectory, "*.nupkg"))
        {
            var unpackagePath = Path.Combine(extractDirectory, Path.GetFileNameWithoutExtension(package));
            UnzipPackage(package, unpackagePath);

            File.Delete(Path.Combine(unpackagePath, "[Content_Types].xml"));
            Directory.Delete(Path.Combine(unpackagePath, "_rels"), recursive: true);
        }
    }

    nuget-pack packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis' nugetPath='.nuget/nuget.exe' each='var nuspecFile in Files.Include(Path.Combine(extractDirectory, "**", "*.nuspec"))'

#copy-darwin-bits target='package-darwin'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_CORECLR_NAME + ".unix")}' include='*.dylib' outputDir='${RUNTIME_CORECLR_DARWIN_x64_BIN}' overwrite='${true}'
    copy sourceDir='${Path.Combine(BUILD_DIR2, BOOTSTRAPPER_FOLDER_NAME, "bin", "darwin", "x64")}' include='dnx' outputDir='${RUNTIME_CORECLR_DARWIN_x64_BIN}' overwrite='${true}'
    copy sourceDir='${SCRIPTS_DIR}' include='dnu.sh' outputDir='${RUNTIME_CORECLR_DARWIN_x64_BIN}' overwrite='${true}'
    @{
        FixShFiles(RUNTIME_CORECLR_DARWIN_x64_BIN);
    }

var CI_DARWIN_DROP_PATH = '${Environment.GetEnvironmentVariable("CI_DARWIN_DROP_PATH")}'

#copy-ci-darwin-bits target='package-runtime' if='!string.IsNullOrEmpty(CI_DARWIN_DROP_PATH)'
    @{
        var extractDirectory = Path.Combine(ARTIFACTS_DIR, "Dnx.Darwin");
    }

    copy sourceDir='${CI_DARWIN_DROP_PATH}' outputDir='${extractDirectory}' include='*.nupkg' overwrite='${true}'

    @{
        foreach (var package in Directory.EnumerateFiles(extractDirectory, "*.nupkg"))
        {
            var unpackagePath = Path.Combine(extractDirectory, Path.GetFileNameWithoutExtension(package));
            UnzipPackage(package, unpackagePath);

            File.Delete(Path.Combine(unpackagePath, "[Content_Types].xml"));
            Directory.Delete(Path.Combine(unpackagePath, "_rels"), recursive: true);
        }
    }

    nuget-pack packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis' nugetPath='.nuget/nuget.exe' each='var nuspecFile in Files.Include(Path.Combine(extractDirectory, "**", "*.nuspec"))'

#nuget-pack-runtime target='package-runtime'
    @{
        UpdateAllNuspecs(RUNTIME_TARGETS, NUSPEC_ROOT, BUILD_DIR2);
    }
    nuget-pack packageVersion='${FULL_VERSION}' outputDir='${BUILD_DIR2}' extra='-NoPackageAnalysis -Properties RuntimeNamePrefix=${RUNTIME_NAME_PREFIX}' nugetPath='.nuget/nuget.exe' each='var nuspecFile in Files.Include(Path.Combine(BUILD_DIR2, "*.nuspec"))'

#nuget-dependencies-install description='Install dependencies to publish directory'
  - var CI_DEPENDENCIES_PATHS = Environment.GetEnvironmentVariable("CI_DEPENDENCIES_PATHS") ?? string.Empty;
  - var dependencyPaths = CI_DEPENDENCIES_PATHS.Split(new[] { (char)';' }, StringSplitOptions.RemoveEmptyEntries);
  - var publishFeed = Environment.GetEnvironmentVariable("NUGET_PUBLISH_FEED");

  kpm-publish targetPackagesDir='${Environment.GetEnvironmentVariable("PACKAGES_PUBLISH_DIR")}' each='var sourcePackagesDir in dependencyPaths'
  nuget-resilient-publish nugetFeed='${publishFeed}' each='var sourcePackagesDir in dependencyPaths' if='!string.IsNullOrEmpty(publishFeed)'

- // ===================== TESTING =====================

#test-package target='integration-test'
    - // We want to run functional tests on both CLR flavors (wrt the RUNTIME_TARGETS)
    - // We want to separate function tests from unit tests
    @{
        var binPaths = new Dictionary<string, string>();

        // Unzip all runtime targets
        foreach (var target in RUNTIME_TARGETS)
        {
            var nupkgPath = Files.Include(Path.Combine(BUILD_DIR2, target.Name + ".*.nupkg")).Single();
            // This is bizzare because it needs to be predictable for the functional tests
            // Each runtime must exist in it's own unique root
            var unpackagePath = Path.Combine(ARTIFACTS_DIR, "test", target.Name, "runtimes", Path.GetFileNameWithoutExtension(nupkgPath));
            var binPath = Path.Combine(unpackagePath, "bin");

            Log.Info("Unpacking " + nupkgPath + " to " + unpackagePath);

            binPaths[target.Name] = binPath;

            // Nuke any previously installed package
            UnzipPackage(nupkgPath, unpackagePath);

            if (IsLinux)
            {
                Exec("chmod", "+x " + Path.Combine(binPath, "dnx"));
                Exec("chmod", "+x " + Path.Combine(binPath, "dnu"));
            }
        }

        // We need to run restore with the new runtime (just one of them).
        // Avoid Mono since it can be unreliable; use first DNX Core target.
        var coreTarget = RUNTIME_TARGETS.First(target => target.Flavor == "coreclr");
        var path = binPaths[coreTarget.Name];

        ExecuteWithPath(path, () =>
        {
            DoRestore(dnvmUse: null);
        });

        // Group by operation system since we only want to run unit tests on a single bitness
        // any = [dnx-mono]
        // win = [dnx-clr-win-x86, dnx-clr-win-x64, dnx-coreclr-win-x86, dnx-coreclr-win-x64]
        // darwin = [dnx-coreclr-darwin-x64]
        // linux = [dnx-coreclr-linux-x64]
        foreach (var group in RUNTIME_TARGETS.GroupBy(t => t.OS))
        {
            // Group by architecture since we only care about a single one for unit tests
            // any
            // any = [dnx-mono]

            // win
            // x86 = [dnx-clr-win-x86, dnx-coreclr-win-x86]
            // x64 = [dnx-clr-win-x64, dnx-coreclr-win-x64]

            // linux
            // x64 = [dnx-coreclr-linux-x64]

            // darwin
            // x64 [dnx-coreclr-darwin-x64]

            foreach (var target in group.GroupBy(t => t.Arch).First())
            {
                var testArgs = string.Empty;
                if (IsLinux)
                {
                    testArgs = " -parallel none";
                }
                else
                {
                    if (target.Flavor == "mono")
                    {
                        // Skip Mono if we're not running on Linux or Mac.
                        continue;
                    }
                }

                var binPath = binPaths[target.Name];

                ExecuteWithPath(binPath, () =>
                {
                    foreach(var projectFile in Files.Include("test/*.Tests/project.json"))
                    {
                        var projectText = File.ReadAllText(projectFile);
                        var project = (JsonObject)Json.Deserialize(projectText);

                        var configs = project.ValueAsJsonObject("frameworks");
                        var targetFrameworks = configs.Keys.Where(k => k.StartsWith("dnx", StringComparison.OrdinalIgnoreCase));
                        foreach (var framework in targetFrameworks)
                        {
                            if (framework == target.Framework)
                            {
                                var projectFolder = Path.GetDirectoryName(projectFile);
                                Dnx("test" + testArgs, projectFolder);
                                break;
                            }
                        }
                    }
                });

                // Functional tests run their own dnx versions
                // we only need to kick them off with Desktop CLR once
                if (target.Flavor == "coreclr")
                {
                    continue;
                }

                // Functional tests dont work on linux and osx yet
                if (target.OS == "darwin" || target.OS == "linux")
                {
                    continue;
                }

                ExecuteWithPath(binPath, () =>
                {
                    foreach(var projectFile in Files.Include("test/*.FunctionalTests/project.json"))
                    {
                        var projectFolder = Path.GetDirectoryName(projectFile);
                        Dnx("test" + testArgs, projectFolder);
                    }
                });
            }
        }
    }

- // ===================== SHARED UTILITIES =====================
macro name='DoRestore' dnvmUse='string'
    dnu command='restore ${ E("KOREBUILD_DNU_RESTORE_OPTIONS") } --parallel src test samples'

#update-tpa
    @{
        var envTrace = Environment.GetEnvironmentVariable("DNX_TRACE");

        try
        {
            var dotnetcoreclrDepFile = Path.Combine(BUILD_DIR2, "dotnetcoreclr-dependencies.txt");

            Environment.SetEnvironmentVariable("DNX_TRACE", "0");

            var target = RUNTIME_TARGETS.Where(t => t.Flavor == "coreclr").First();
            File.WriteAllText(dotnetcoreclrDepFile, string.Join(Environment.NewLine, ListDependencyAssemblies(Path.Combine(ROOT, "src", BOOTSTRAPPER_HOST_NAME), target)));

            var tpaProjects = new[] {
                BOOTSTRAPPER_HOST_NAME,
                BOOTSTRAPPER_CORECLR_MANAGED_NAME,
                "Microsoft.Extensions.PlatformAbstractions",
                "Microsoft.Dnx.Loader"
            };

            UpdateTpa(dotnetcoreclrDepFile, tpaProjects, Path.Combine(ROOT, "src", BOOTSTRAPPER_COMMON_FOLDER_NAME, "tpa.cpp"));
        }
        finally
        {
            Environment.SetEnvironmentVariable("DNX_TRACE", envTrace);
        }
    }

#ensure-clang
    @{
        if (CLANG == null || !File.Exists(CLANG))
        {
            Log.Warn("clang++ not found. Please ensure you have clang++ or clang++3.5 on the path or set CXX to a path to clang++.");
            Environment.Exit(1);
        }
    }

#ensure-msbuild
    @{
        if (!File.Exists(MSBUILD))
        {
            Log.Warn("msbuild version 14 not found. Please ensure you have the VS 2015 C++ SDK installed.");
            Environment.Exit(1);
        }
    }

#ensure-vs-redist
    @{
        if (!Directory.Exists(VS_REDIST_ROOT))
        {
            Log.Warn("Visual Studio C++ Redistributable not found. Please ensure you have the VS 2015 C++ SDK installed.");
            Environment.Exit(1);
        }
    }

#dev-install
    @{
        foreach (var target in RUNTIME_TARGETS)
        {
            InstallDevRuntime(target.TargetFolder);
        }
    }

functions @{
    private static readonly string[] TPA_IGNORED_ASSEMBLIES = new [] {
        "Microsoft.Extensions.HashCodeCombiner.Sources"
    };

    private static readonly string _defaultLocalRuntimeHomeDir = ".dnx";
    private static readonly string _runtimesSubDir = "runtimes";

    bool CanBuildForLinux
    {
        get
        {
            return string.Equals(Uname(), "Linux");
        }
    }
    
    bool CanBuildForCentOS
    {
        get
        {
            return LinuxDistro("centos");
        }
    }

    bool CanBuildForDarwin
    {
        get
        {
            return string.Equals(Uname(), "Darwin");
        }
    }

    bool CanBuildForWindows
    {
        get
        {
            var p = (int)Environment.OSVersion.Platform;
            return (p != 4) && (p != 6) && (p != 128);
        }
    }

    bool IsTravis
    {
        get
        {
            var travis = Environment.GetEnvironmentVariable("TRAVIS");
            return string.Equals(travis, "true");
        }
    }

    public bool LinuxDistro(string distro)
    {
        string result;
        ExecuteAndRedirectOutput("cat", "/etc/os-release", out result);
        return result.Contains(distro);
    }

    public string Uname()
    {
        try
        {
            string uname;
            ExecuteAndRedirectOutput("uname", "", out uname);
            return string.IsNullOrEmpty(uname) ? null : uname.Trim();
        }
        catch
        {
            return null;
        }
    }

    public string SearchForClang()
    {
        var CXX = Environment.GetEnvironmentVariable("CXX");

        if (!string.IsNullOrEmpty(CXX))
        {
            return CXX;
        }

        foreach(var dir in Environment.GetEnvironmentVariable("PATH").Split(Path.PathSeparator))
        {
            if (File.Exists(Path.Combine(dir, "clang++")))
            {
                return Path.Combine(dir, "clang++");
            }
            else if (File.Exists(Path.Combine(dir, "clang++-3.5")))
            {
                return Path.Combine(dir, "clang++-3.5");
            }
        }

        return null;
    }

    public void ExecuteWithPath(string binPath, Action action)
    {
        var envPath = Environment.GetEnvironmentVariable("PATH");

        try
        {
            // We want to run unit tests against all runtime targets
            Environment.SetEnvironmentVariable("PATH", binPath + Path.PathSeparator + envPath);
            Log.Info("Adding " + binPath + " to the PATH");

            action();
        }
        finally
        {
            Environment.SetEnvironmentVariable("PATH", envPath);
        }
    }

    void UpdateAllNuspecs(List<RuntimeTarget> targets, string sourcePath, string outputPath)
    {
        foreach (var target in targets)
        {
            var nuspecFile = Path.Combine(sourcePath, target.Name + ".nuspec");

            XDocument xdoc;
            using (var fs = File.OpenRead(nuspecFile))
            {
                xdoc = XDocument.Load(fs);
            }

            var filesNode = xdoc.Descendants("files").SingleOrDefault();

            foreach (var fileNode in filesNode.Elements("file"))
            {
                var srcAttr = fileNode.Attribute("src");
                if (srcAttr != null)
                {
                    srcAttr.Value = srcAttr.Value.Replace("\\", Path.DirectorySeparatorChar.ToString());
                }

                var excludeAttr = fileNode.Attribute("exclude");
                if (excludeAttr != null)
                {
                    excludeAttr.Value = excludeAttr.Value.Replace("\\", Path.DirectorySeparatorChar.ToString());
                }
            }

            var fileWriteTo = Path.Combine(outputPath, Path.GetFileName(nuspecFile));
            xdoc.Save(fileWriteTo);
        }
    }

    string FindRuntimeFolder()
    {
        var profileDirectory = Environment.GetEnvironmentVariable("USERPROFILE");

        if (string.IsNullOrEmpty(profileDirectory))
        {
            profileDirectory = Environment.GetEnvironmentVariable("HOME");
        }

        return Path.Combine(profileDirectory, _defaultLocalRuntimeHomeDir);
    }

    string FindRuntimePackagesFolder()
    {
        return Path.Combine(FindRuntimeFolder(), _runtimesSubDir);
    }

    void InstallDevRuntime(string binPath)
    {
        var sourceDir = Path.GetDirectoryName(binPath);
        var sourceRuntime= Path.GetFileName(sourceDir);
        var destinationRuntime= sourceRuntime+ ".1.0.0-dev";
        var destinationDir = Path.Combine(FindRuntimePackagesFolder(), destinationRuntime);

        // Overwrite existing symbol link
        if (Directory.Exists(destinationDir))
        {
            Directory.Delete(destinationDir);
        }

        // Trim runtime name prefix part from alias to keep it short
        var alias = sourceRuntime.Substring(sourceRuntime.IndexOf('-') + 1) + "-dev";

        var symlinkProgram = "cmd";
        var symlinkProgramArgs = "/C mklink /J {0} {1}";

        var versionManagerProgram = "cmd";
        var versionManagerProgramArgs = "/C dnvm alias {0} {1}";

        if (IsLinux)
        {
            symlinkProgram = "ln";
            symlinkProgramArgs = "-s {1} {0}";

            versionManagerProgram = "bash";
            versionManagerProgramArgs =
                "-c 'source " +
                Path.Combine(FindRuntimeFolder(), "dnvm", "dnvm.sh") +
                " && dnvm alias {0} {1}'";
        }

        symlinkProgramArgs = String.Format(symlinkProgramArgs,
            destinationDir,
            sourceDir);

        versionManagerProgramArgs = String.Format(versionManagerProgramArgs,
            alias,
            destinationRuntime);

        Exec(symlinkProgram, symlinkProgramArgs);
        Exec(versionManagerProgram, versionManagerProgramArgs);
    }

    void FixShFiles(string directory)
    {
        // Rename all .sh files to remove the sh
        foreach (var shFile in Files.Include(Path.Combine(directory, "*.sh")))
        {
            var targetShFile = Path.Combine(Path.GetDirectoryName(shFile),
                                            Path.GetFileNameWithoutExtension(shFile));
            if (File.Exists(targetShFile))
            {
                File.Delete(targetShFile);
            }

            // Make sure new lines are \n (\r\n messes up the bash script)
            var script = File.ReadAllText(shFile).Replace('\r\n', '\n');
            File.Move(shFile, targetShFile);
            File.WriteAllText(targetShFile, script);
        }
    }

    void UnzipPackage(string nupkgPath, string unpackagePath)
    {
        if (Directory.Exists(unpackagePath))
        {
            Log.Info("Deleting " + Path.GetDirectoryName(unpackagePath));
            Directory.Delete(Path.GetDirectoryName(unpackagePath), recursive:true);
        }

        Directory.CreateDirectory(unpackagePath);

        if (IsMono)
        {
            // System.IO.Compression gives weird errors on mono to do with invalid dates
            // we're going to use unzip instead
            Exec("unzip", nupkgPath + " -d " + unpackagePath);
        }
        else
        {
            System.IO.Compression.ZipFile.ExtractToDirectory(
                nupkgPath,
                unpackagePath);
        }
    }

    int ExecuteAndRedirectOutput(string command, string argument, out string content)
    {
        var procStartInfo = new ProcessStartInfo
        {
            FileName = command,
            Arguments = argument,
            WorkingDirectory = Directory.GetCurrentDirectory(),
            UseShellExecute = false
        };
        procStartInfo.EnvironmentVariables["DNX_TRACE"] = "0";
        procStartInfo.RedirectStandardOutput = true;

        var process = Process.Start(procStartInfo);
        content = process.StandardOutput.ReadToEnd();
        process.WaitForExit();

        return process.ExitCode;
    }

    int ExecuteAndRedirectOutput(string command, string argument, string outputFile)
    {
        string content;
        int exitCode = ExecuteAndRedirectOutput(command, argument, out content);

        File.WriteAllText(outputFile, content);

        return exitCode;
    }

    HashSet<string> CopyRequiredAssemblies(string projectFolder, string targetFolder, HashSet<string> ignoreDependencies, RuntimeTarget target)
    {
        var dependencies = ListDependencyAssemblies(projectFolder, target);

        if (!Directory.Exists(targetFolder))
        {
            Directory.CreateDirectory(targetFolder);
        }

        try
        {
            var filesList = new List<string>();
            foreach (var file in dependencies)
            {
                if (!(ignoreDependencies != null && ignoreDependencies.Contains(Path.GetFileName(file))))
                {
                    var targetFilePath = Path.Combine(targetFolder, Path.GetFileName(file));
                    if (!Quiet)
                    {
                        Log.Info("Copying " + file + " to " + targetFilePath);
                    }
                    File.Copy(file, targetFilePath, true);

                    // Record the copied files
                    filesList.Add(file + " => " + targetFilePath);
                }
            }
            File.WriteAllLines(Path.Combine(targetFolder, "files.lst"), filesList);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(string.Format("Fail to copy runtime assemblies [{0}]", ex.Message));
        }

        var dependencyNames = new HashSet<string>();
        foreach (var file in dependencies)
        {
            dependencyNames.Add(Path.GetFileName(file));
        }

        return dependencyNames;
    }

    HashSet<string> ListDependencyAssemblies(string projectFolder, RuntimeTarget target)
    {
        var runtimeTarget = "";
        if(target.OS == "win")
        {
            if(target.Arch == "arm")
            {
                runtimeTarget = "win10";
            }
            else
            {
                runtimeTarget = "win7";
            }
        }
        else if(target.OS == "linux")
        {
            if (CanBuildForCentOS)
            {
                runtimeTarget = "centos.7";
            }
            else
            {
                runtimeTarget = "ubuntu.14.04";
            }
        }
        else if(target.OS == "darwin")
        {
            runtimeTarget = "osx.10.10";
        }

        runtimeTarget += "-" + target.Arch;

        var args = string.Format("--runtime {0}", runtimeTarget);

        if (target.Flavor == "mono")
        {
            args = "";
        }

        string tmp;
        var home = "USERPROFILE";
        if (IsLinux)
        {
            ExecuteAndRedirectOutput("dnu", string.Format("restore {0} {1}", projectFolder, args), out tmp);
            home = "HOME";
        }
        else
        {
            ExecuteAndRedirectOutput("cmd", string.Format("/C dnu restore {0} {1}", projectFolder, args), out tmp);
        }

        if (target.Flavor == "mono")
        {
            runtimeTarget = "DNX,Version=v4.5.1";
        }
        else
        {
            runtimeTarget = (target.Flavor == "coreclr" ? "DNXCore,Version=v5.0/" : "DNX,Version=v4.5.1/") + runtimeTarget;
        }

        var packagesFolder = Environment.GetEnvironmentVariable("DNX_PACKAGES");
        if (string.IsNullOrEmpty(packagesFolder))
        {
            packagesFolder = Path.Combine(Environment.GetEnvironmentVariable(home), ".dnx", "packages");
        }

        var lockFile = File.ReadAllText(Path.Combine(projectFolder, "project.lock.json"));
        var obj = (JsonObject)Json.Deserialize(lockFile);
        var runtimePackages = obj.ValueAsJsonObject("targets").ValueAsJsonObject(runtimeTarget);
        var projects = obj.ValueAsJsonObject("libraries");

        var projectAssemblies = new HashSet<string>();
        foreach (var package in runtimePackages.Keys)
        {
            var lib = runtimePackages.ValueAsJsonObject(package);
            if(lib.ValueAsString("type") == "project")
            {
                var name = package.Substring(0, package.IndexOf('/'));
                if (name.EndsWith(".Sources") || name.Contains("Microsoft.Dnx.Runtime.Internals"))
                {
                    continue;
                }
                var path = Path.Combine(Directory.GetCurrentDirectory(), "artifacts", "build", name, target.Framework, name + ".dll");
                if (!File.Exists(path))
                {
                    var directoryName = target.Framework == "dnx451" ? "net451" : "dotnet5.4";
                    path = Path.Combine(Directory.GetCurrentDirectory(), "artifacts", "build", name, directoryName, name + ".dll");
                }

                projectAssemblies.Add(path);
            }

            if (package.Contains(".Sources") || package.Contains("Microsoft.Dnx.Runtime.Internals"))
            {
                continue;
            }

            var runtime = lib.ValueAsJsonObject("runtime");
            if (runtime != null)
            {
                foreach (var dll in runtime.Keys)
                {
                    projectAssemblies.Add(Path.Combine(packagesFolder, Path.Combine(package, dll)));
                }
            }

            var tools = "";
            var native = lib.ValueAsJsonObject("native");
            if (native != null)
            {
                foreach (var dll in native.Keys)
                {
                    projectAssemblies.Add(Path.Combine(packagesFolder, Path.Combine(package, dll)));

                    // this is to grab sos.dll and crossgen.exe
                    if (dll.EndsWith("coreclr.dll") || dll.Contains("libcoreclr"))
                    {
                        tools = Path.Combine(packagesFolder, Path.Combine(package, "tools"));
                    }
                }
            }

            if (!string.IsNullOrEmpty(tools))
            {
                if (Directory.Exists(tools))
                {
                    foreach (var tool in Directory.EnumerateFiles(tools))
                    {
                        projectAssemblies.Add(tool);
                    }
                }
            }
        }

        return projectAssemblies;
    }

    string[] FindAllProjects(params string[] folders)
    {
      return FindAllFiles("project.json", folders);
    }

    string[] FindAllFiles(string fileName, params string[] folders)
    {
      return folders.Select(folder => Path.Combine("src", folder))
                    .Where(folder => Directory.Exists(folder))
                    .SelectMany(folder => Directory.GetFiles(folder, fileName, SearchOption.AllDirectories))
                    .ToArray();
    }

    void UpdateTpa(string input, string[] assemblies, string output)
    {
        var tpa = File.ReadAllLines(input)
                      .Where(l => File.Exists(l))
                      .Select(l => Path.GetFileNameWithoutExtension(l))
                      .Concat(assemblies)
                      .Except(TPA_IGNORED_ASSEMBLIES)
                      .OrderBy(s => s)
                      .ToArray();

        var content = new List<string>();

        content.Add(@"// Copyright (c) .NET Foundation. All rights reserved.");
        content.Add(@"// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.");
        content.Add(@"");
        content.Add(@"// This file will be dynamically updated during build to generate a");
        content.Add(@"// minimal trusted platform assemblies list");
        content.Add(string.Empty);
        content.Add("#include \"stdafx.h\"");
        content.Add("#include <vector>");
        content.Add("#include <string>");
        content.Add("#include \"xplat.h\"");
        content.Add(string.Empty);
        content.Add("const std::vector<const dnx::char_t*> CreateTpaBase(bool native_images)");
        content.Add("{");
        content.Add("    return native_images");
        content.Add("        ? std::vector<const dnx::char_t*>");
        content.Add("        {");
        for (int i = 0; i < tpa.Length; ++i)
        {
            content.Add(string.Format("            _X(\"{1}{2}\"),", i, tpa[i], ".ni.dll"));
        }
        content.Add("        }");
        content.Add("        : std::vector<const dnx::char_t*>");
        content.Add("        {");
        for (int i = 0; i < tpa.Length; ++i)
        {
            content.Add(string.Format("            _X(\"{1}{2}\"),", i, tpa[i], ".dll"));
        }

        content.Add("        };");
        content.Add("}");

        File.WriteAllLines(output, content);
    }

    public class RuntimeTarget
    {
        public string Name { get; set; }
        public string TargetFolder { get; set; }
        public string Framework { get; set; }
        public string Arch { get; set; }
        public string OS { get; set; }
        public string Flavor { get; set; }
    }
}
